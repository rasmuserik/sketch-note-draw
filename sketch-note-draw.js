// Generated by CoffeeScript 1.6.3
(function() {
  var ctx, drawSegment, hold, info, kind, layout, multitouch, onReady, redraw, rootX, rootX0, rootY, rootY0, scale, scale0, stroke, strokes, t, transform, use,
    __slice = [].slice;

  if (typeof isNodeJs === "undefined" || typeof runTest === "undefined") {
    (function() {
      var root;
      root = typeof window === "undefined" ? global : window;
      if (typeof isNodeJs === "undefined") {
        root.isNodeJs = typeof process !== "undefined";
      }
      if (typeof isWindow === "undefined") {
        root.isWindow = typeof window !== "undefined";
      }
      if (typeof isPhoneGap === "undefined") {
        root.isPhoneGap = typeof (typeof document !== "undefined" && document !== null ? document.ondeviceready : void 0) !== "undefined";
      }
      if (typeof runTest === "undefined") {
        return root.runTest = (isNodeJs ? process.argv[2] === "test" : location.hash.slice(1) === "test");
      }
    })();
  }

  use = isNodeJs ? (function(module) {
    return require(module);
  }) : (function(module) {
    return window[module];
  });

  onReady = function(fn) {
    if (isWindow) {
      if (document.readystate !== "complete") {
        return fn();
      } else {
        return setTimeout((function() {
          return onReady(fn);
        }), 17);
      }
    }
  };

  t = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

  info = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    t.shift();
    t.push(args);
    return log.innerHTML = JSON.stringify(t);
  };

  strokes = [];

  stroke = [];

  transform = false;

  hold = false;

  rootX = rootX0 = 0;

  rootY = rootY0 = 0;

  scale = scale0 = 1;

  ctx = void 0;

  kind = void 0;

  multitouch = void 0;

  redraw = function() {
    var i, _i, _j, _len, _ref, _results;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    _results = [];
    for (_i = 0, _len = strokes.length; _i < _len; _i++) {
      stroke = strokes[_i];
      ctx.beginPath();
      ctx.moveTo((stroke[0] + rootX) * scale, (stroke[1] + rootY) * scale);
      for (i = _j = 2, _ref = stroke.length; _j <= _ref; i = _j += 2) {
        ctx.lineTo((stroke[i] + rootX) * scale, (stroke[i + 1] + rootY) * scale);
      }
      _results.push(ctx.stroke());
    }
    return _results;
  };

  drawSegment = function(x0, y0, x1, y1) {
    ctx.beginPath();
    ctx.moveTo((x0 + rootX) * scale, (y0 + rootY) * scale);
    ctx.lineTo((x1 + rootX) * scale, (y1 + rootY) * scale);
    return ctx.stroke();
  };

  layout = function() {
    canvas.style.position = "absolute";
    canvas.style.top = "0px";
    canvas.style.left = "0px";
    canvas.width = window.innerWidth;
    return canvas.height = window.innerHeight;
  };

  onReady(function() {
    var dist;
    ctx = canvas.getContext("2d");
    layout();
    dist = function(x0, y0, x1, y1) {
      var dx, dy;
      dx = x0 - x1;
      dy = y0 - y1;
      return Math.sqrt(dx * dx + dy * dy);
    };
    uu.domListen(canvas, "touchstart", function(e) {
      var x, y;
      e.preventDefault();
      if (1 === e.touches.length) {
        x = e.touches[0].clientX / scale - rootX;
        y = e.touches[0].clientY / scale - rootY;
        stroke = [x, y];
        return kind = "draw";
      } else if (2 === e.touches.length) {
        kind = "multitouch";
        return multitouch = {
          x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
          y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
          dist: dist(e.touches[0].clientX, e.touches[0].clientY, e.touches[1].clientX, e.touches[1].clientY),
          rootX: rootX,
          rootY: rootY,
          scale: scale
        };
      }
    });
    uu.domListen(canvas, "touchmove", function(e) {
      var current, dscale, x, y;
      e.preventDefault();
      if ("draw" === kind) {
        x = e.touches[0].clientX / scale - rootX;
        y = e.touches[0].clientY / scale - rootY;
        drawSegment(stroke[stroke.length - 2], stroke[stroke.length - 1], x, y);
        stroke.push(x, y);
      }
      if ("multitouch" === kind) {
        current = {
          x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
          y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
          dist: dist(e.touches[0].clientX, e.touches[0].clientY, e.touches[1].clientX, e.touches[1].clientY)
        };
        scale = multitouch.scale * current.dist / multitouch.dist;
        dscale = multitouch.scale / scale - 1;
        rootX = multitouch.rootX + current.x - multitouch.x + current.x * dscale;
        rootY = multitouch.rootY + current.y - multitouch.y + current.y * dscale;
        redraw();
        ctx.fillStyle = "red";
        ctx.fillText(JSON.stringify([rootX, rootY, multitouch]), 10, 10);
        ctx.fillRect(e.touches[0].clientX, e.touches[0].clientY, 5, 5);
        ctx.fillStyle = "blue";
        ctx.fillRect(e.touches[1].clientX, e.touches[1].clientY, 5, 5);
        ctx.fillStyle = "green";
        ctx.fillRect((e.touches[0].clientX + e.touches[1].clientX) / 2, (e.touches[0].clientY + e.touches[1].clientY) / 2, 5, 5);
        return ctx.fillStyle = "black";
      }
    });
    uu.domListen(canvas, "touchend", function(e) {
      if ("draw" === kind) {
        strokes.push(stroke);
      }
      return kind = "end";
    });
    return uu.domListen(window, "resize", function(e) {
      return layout();
    });
  });

  /*
    events = Hammer(window)
    events.on "drag", (e)->
      x = (e.gesture.touches[0].clientX) / scale - rootX
      y = (e.gesture.touches[0].clientY) / scale - rootY
      drawSegment stroke[stroke.length - 2], stroke[stroke.length - 1], x, y
      stroke.push x, y
  
    events.on "dragstart", (e) ->
      x = (e.gesture.touches[0].clientX) / scale - rootX
      y = (e.gesture.touches[0].clientY) / scale - rootY
      stroke = [x, y]
      console.log "dragstart"
      transform = false
      hold = false
  
    events.on "transformstart transformend", ->
      transform = true
  
    events.on "transformstart", (e) ->
      scale0 = scale
      rootX0 = rootX - e.gesture.deltaX
      rootY0 = rootY - e.gesture.deltaY / scale
  
    events.on "transform", (e) ->
      rootX = rootX0 + e.gesture.deltaX / scale
      rootY = rootY0 + e.gesture.deltaY / scale
      scale = scale0 * e.gesture.scale
      redraw()
  
  
    events.on "hold tap", (e) ->
      console.log e
      hold = true
      redraw()
      #menu()
  
    events.on "dragend", ->
      if !transform and !hold
        strokes.push stroke
      else
        redraw()
  */


}).call(this);
