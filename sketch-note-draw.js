// Generated by CoffeeScript 1.6.3
(function() {
  var addButtons, allStrokes, buttonAwesome, buttonFns, buttonList, calcPos, ctx, currentStroke, dist, drawEntry, drawGrid, drawSegment, findDimensions, gridCols, gridEvents, gridMargin, gridNext, gridSize, gridStart, gridX0, gridY0, hasTouch, hold, kind, layout, loadDB, loadGrid, loadGridHandleTouch, multitouch, nextPath, nextStroke, onReady, panPos, redo, redraw, rootX, rootY, save, scale, scaleFit, showLoadGrid, strokes, touchend, touchmove, touchstart, transform, use, zoomFn;

  if (typeof isNodeJs === "undefined" || typeof runTest === "undefined") {
    (function() {
      var root;
      root = typeof window === "undefined" ? global : window;
      if (typeof isNodeJs === "undefined") {
        root.isNodeJs = typeof process !== "undefined";
      }
      if (typeof isWindow === "undefined") {
        root.isWindow = typeof window !== "undefined";
      }
      if (typeof isPhoneGap === "undefined") {
        root.isPhoneGap = typeof (typeof document !== "undefined" && document !== null ? document.ondeviceready : void 0) !== "undefined";
      }
      if (typeof runTest === "undefined") {
        return root.runTest = (isNodeJs ? process.argv[2] === "test" : location.hash.slice(1) === "test");
      }
    })();
  }

  use = isNodeJs ? (function(module) {
    return require(module);
  }) : (function(module) {
    return window[module];
  });

  onReady = function(fn) {
    if (isWindow) {
      if (document.readystate !== "complete") {
        return fn();
      } else {
        return setTimeout((function() {
          return onReady(fn);
        }), 17);
      }
    }
  };

  if (window.devicePixelRatio == null) {
    window.devicePixelRatio = 1;
  }

  strokes = [];

  redo = [];

  nextStroke = void 0;

  nextPath = void 0;

  currentStroke = {
    prev: null,
    path: [],
    date: 1
  };

  allStrokes = {
    1: currentStroke
  };

  transform = false;

  hold = false;

  rootX = 0;

  rootY = 0;

  scale = 1;

  ctx = void 0;

  kind = void 0;

  multitouch = void 0;

  hasTouch = false;

  panPos = void 0;

  loadGrid = false;

  findDimensions = function(stroke) {
    var i, maxX, maxY, minX, minY, update, _i, _ref;
    if (!stroke || !stroke.prev) {
      return [0, 0, 1, 1];
    }
    minY = minX = Number.MAX_VALUE;
    maxY = maxX = -Number.MAX_VALUE;
    update = function(x, y) {
      minY = Math.min(y, minY);
      minX = Math.min(x, minX);
      maxY = Math.max(y, maxY);
      return maxX = Math.max(x, maxX);
    };
    while (stroke && stroke.prev) {
      for (i = _i = 0, _ref = stroke.path.length - 1; _i <= _ref; i = _i += 2) {
        update(stroke.path[i], stroke.path[i + 1]);
      }
      stroke = allStrokes[stroke.prev];
    }
    return [minX, minY, maxX, maxY];
  };

  scaleFit = function() {
    var h, maxX, maxY, minX, minY, w, _ref;
    _ref = findDimensions(currentStroke), minX = _ref[0], minY = _ref[1], maxX = _ref[2], maxY = _ref[3];
    w = maxX - minX;
    h = maxY - minY;
    console.log(w, h, canvas.width, canvas.height);
    scale = Math.min((canvas.width - 6) / w, (canvas.height - 90) / h);
    rootX = -minX + ((canvas.width / scale) - (maxX - minX)) / 2;
    rootY = -minY + ((canvas.height / scale) - (maxY - minY)) / 2;
    console.log(minX, minY, rootX, rootY);
    return console.log(w, h, canvas.width, canvas.height);
  };

  redraw = function() {
    var i, path, stroke, _i, _ref, _results;
    if (loadGrid) {
      return drawGrid();
    }
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "black";
    ctx.lineWidth = Math.sqrt(canvas.width * canvas.height) * 0.002;
    stroke = currentStroke;
    ctx.strokeStyle = "black";
    _results = [];
    while (stroke.prev) {
      path = stroke.path;
      ctx.beginPath();
      ctx.moveTo((path[0] + rootX) * scale, (path[1] + rootY) * scale);
      for (i = _i = 2, _ref = path.length; _i <= _ref; i = _i += 2) {
        ctx.lineTo((path[i] + rootX) * scale, (path[i + 1] + rootY) * scale);
      }
      ctx.stroke();
      _results.push(stroke = allStrokes[stroke.prev]);
    }
    return _results;
  };

  drawSegment = function(x0, y0, x1, y1) {
    ctx.beginPath();
    ctx.moveTo((x0 + rootX) * scale, (y0 + rootY) * scale);
    ctx.lineTo((x1 + rootX) * scale, (y1 + rootY) * scale);
    return ctx.stroke();
  };

  layout = function() {
    var info;
    canvas.style.position = "absolute";
    canvas.style.top = "0px";
    canvas.style.left = "0px";
    canvas.height = window.innerHeight * window.devicePixelRatio | 0;
    canvas.width = window.innerWidth * window.devicePixelRatio | 0;
    canvas.style.width = "" + window.innerWidth + "px";
    canvas.style.height = "" + window.innerHeight + "px";
    info = document.getElementById("info");
    info.style.fontSize = "" + (Math.min(window.innerHeight, window.innerWidth) >> 4) + "px";
    info.style.left = "0px";
    info.style.width = "" + window.innerWidth + "px";
    info.style.top = "" + ((window.innerHeight - info.offsetHeight) * 0.4) + "px";
    addButtons();
    return redraw();
  };

  dist = function(x0, y0, x1, y1) {
    var dx, dy;
    dx = x0 - x1;
    dy = y0 - y1;
    return Math.sqrt(dx * dx + dy * dy);
  };

  gridSize = 60 * window.devicePixelRatio | 0;

  gridMargin = 10 * window.devicePixelRatio | 0;

  gridNext = void 0;

  gridStart = void 0;

  gridX0 = void 0;

  gridY0 = void 0;

  gridCols = void 0;

  gridEvents = void 0;

  uu.log("starting sketch-note-draw");

  calcPos = function(w) {
    var count, i, indent, totalMargin;
    count = (w - gridMargin) / (gridSize + gridMargin) | 0;
    totalMargin = w - count * gridSize;
    indent = (w - gridMargin * (count - 1) - count * gridSize) >> 1;
    return (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = count - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(indent + (i * (gridSize + gridMargin)));
      }
      return _results;
    })();
  };

  drawEntry = function(entry, i, count, x, y) {
    var d, drawing, dx, dy, fn, fontSize, maxX, maxY, minX, minY, next, px, py, rescale, size, stroke, texts, _i, _j, _k, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    if (1 === i) {
      drawing = {
        prev: null,
        path: []
      };
      texts = ["new", ""];
      next = gridNext;
      fn = function() {
        return currentStroke = allStrokes[1];
      };
    } else if (2 === i) {
      drawing = currentStroke;
      texts = ["current", ""];
      next = gridNext;
      fn = function() {
        return console.log("current");
      };
    } else if (count === i && gridNext && gridNext.prevSave) {
      drawing = {
        prev: null,
        path: []
      };
      texts = ["more", ""];
      next = gridNext;
      fn = function() {
        return console.log("more");
      };
    } else {
      if (!gridNext) {
        return;
      }
      drawing = gridNext;
      d = new Date(drawing.date);
      texts = [d.toString().split(" ")[4], d.toString().split(" ").slice(1, 3).join(" ")];
      next = allStrokes[drawing.prevSave];
      fn = function() {
        return currentStroke = drawing;
      };
    }
    gridEvents.push(fn);
    ctx.fillStyle = "black";
    ctx.fillRect(x - 1, y - 1, gridSize + 2, gridSize + 2);
    ctx.fillStyle = "white";
    ctx.fillRect(x, y, gridSize, gridSize);
    _ref = findDimensions(drawing), minX = _ref[0], minY = _ref[1], maxX = _ref[2], maxY = _ref[3];
    size = Math.max(maxX - minX, maxY - minY);
    px = minX - (size - (maxX - minX)) / 2;
    py = minY - (size - (maxY - minY)) / 2;
    rescale = gridSize / size;
    ctx.lineWidth = 1;
    stroke = drawing;
    ctx.strokeStyle = "black";
    while (stroke && stroke.prev) {
      ctx.beginPath();
      for (i = _i = 2, _ref1 = stroke.path.length - 1; _i <= _ref1; i = _i += 2) {
        ctx.lineTo(x + (stroke.path[i] - px) * rescale, y + (stroke.path[i + 1] - py) * rescale);
      }
      ctx.stroke();
      stroke = allStrokes[stroke.prev];
    }
    fontSize = (gridSize * .25) | 0;
    ctx.font = "" + fontSize + "px sans-serif";
    ctx.fillStyle = "rgba(255,255,255,0.4)";
    for (dx = _j = _ref2 = -window.devicePixelRatio, _ref3 = window.devicePixelRatio, _ref4 = window.devicePixelRatio * .5; _ref4 > 0 ? _j <= _ref3 : _j >= _ref3; dx = _j += _ref4) {
      for (dy = _k = _ref5 = -window.devicePixelRatio, _ref6 = window.devicePixelRatio, _ref7 = window.devicePixelRatio * .5; _ref7 > 0 ? _k <= _ref6 : _k >= _ref6; dy = _k += _ref7) {
        ctx.fillText(texts[0], x + fontSize * .2 + dx, y + fontSize * 1 + dy);
        ctx.fillText(texts[1], x + fontSize * .2 + dx, y + fontSize * 2 + dy);
      }
    }
    ctx.fillStyle = "black";
    ctx.fillText(texts[0], x + fontSize * .2, y + fontSize * 1);
    ctx.fillText(texts[1], x + fontSize * .2, y + fontSize * 2);
    return gridNext = next;
  };

  drawGrid = function() {
    var count, entry, i, x, xs, y, ys, _i, _len, _results;
    gridEvents = [];
    gridNext = gridStart;
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    xs = calcPos(+canvas.width);
    ys = calcPos(+canvas.height);
    gridX0 = xs[0];
    gridY0 = ys[0];
    gridCols = xs.length;
    entry = {
      stroke: currentStroke,
      text: "new"
    };
    i = 0;
    count = ys.length * xs.length;
    _results = [];
    for (_i = 0, _len = ys.length; _i < _len; _i++) {
      y = ys[_i];
      _results.push((function() {
        var _j, _len1, _results1;
        _results1 = [];
        for (_j = 0, _len1 = xs.length; _j < _len1; _j++) {
          x = xs[_j];
          ++i;
          _results1.push(entry = drawEntry(entry, i, count, x, y));
        }
        return _results1;
      })());
    }
    return _results;
  };

  save = function() {
    var cs;
    if (currentStroke.prevSave || 1 === currentStroke.date) {
      return;
    }
    cs = currentStroke;
    return localforage.getItem("sketchSaved", function(sketchId) {
      cs.prevSave = sketchId;
      localforage.setItem("sketchStroke" + cs.date, cs);
      return localforage.setItem("sketchSaved", cs.date);
    });
  };

  showLoadGrid = function() {
    gridStart = currentStroke;
    document.getElementById("info").style.opacity = "0";
    uu.sleep(1, function() {
      return document.getElementById("info").style.display = "none";
    });
    (document.getElementById("buttons")).style.display = "none";
    loadGrid = true;
    save();
    return localforage.getItem("sketchSaved", function(sketchId) {
      gridStart = allStrokes[sketchId || 1];
      return redraw();
    });
  };

  loadGridHandleTouch = function(x, y) {
    var _name;
    x = (x * window.devicePixelRatio - gridX0) / (gridSize + gridMargin) | 0;
    y = (y * window.devicePixelRatio - gridY0) / (gridSize + gridMargin) | 0;
    if (typeof gridEvents[_name = x + y * gridCols] === "function") {
      gridEvents[_name]();
    }
    (document.getElementById("buttons")).style.display = "inline";
    loadGrid = false;
    scaleFit();
    return redraw();
  };

  buttonList = ["pan", "files", "undo", "pan", "pan", "zoomin", "zoomout", "pan"];

  buttonAwesome = {
    pan: "arrows",
    zoomin: "search-plus",
    zoomout: "search-minus",
    undo: "undo",
    redo: "repeat",
    "new": "square-o",
    download: "picture-o",
    save: "cloud-upload gray",
    load: "cloud-download gray",
    info: "question",
    files: "th"
  };

  zoomFn = function() {
    var zoomScale;
    if ("zoomin" === kind || "zoomout" === kind) {
      setTimeout(zoomFn, 20);
      zoomScale = kind === "zoomin" ? 1.05 : 1 / 1.05;
      scale *= zoomScale;
      rootX += canvas.width / scale * (1 - zoomScale) / 2;
      rootY += canvas.height / scale * (1 - zoomScale) / 2;
      return setTimeout(redraw, 0);
    }
  };

  buttonFns = {
    pan: function() {
      return panPos = void 0;
    },
    files: showLoadGrid,
    download: function() {
      /*
      a = document.createElement "a"
      a.download = "sketch-note-draw.png"
      a.href = canvas.toDataURL()
      a.target = "_blank"
      document.body.appendChild a
      a.click()
      document.body.removeChild a
      */

      return window.open(canvas.toDataURL());
    },
    zoomin: zoomFn,
    zoomout: zoomFn,
    undo: function() {
      if (currentStroke.prev) {
        redo.push(currentStroke);
        currentStroke = allStrokes[currentStroke.prev];
        return redraw();
      }
    },
    redo: function() {
      if (redo.length) {
        currentStroke = redo.pop();
        return redraw();
      }
    },
    "new": function() {
      if (strokes.length) {
        currentStroke = allStrokes[1];
        return redraw();
      }
    }
  };

  addButtons = function() {
    var button, buttonId, buttons, i, s, _fn, _i, _ref, _results;
    buttons = document.getElementById("buttons");
    buttons.innerHTML = "";
    _fn = function(buttonId) {
      var touchhandler;
      touchhandler = function(e) {
        e.stopPropagation();
        e.preventDefault();
        kind = buttonId;
        return typeof buttonFns[buttonId] === "function" ? buttonFns[buttonId]() : void 0;
      };
      button.ontouchstart = function(e) {
        hasTouch = true;
        return touchhandler(e);
      };
      return button.onmousedown = function(e) {
        if (!hasTouch) {
          return touchhandler(e);
        }
      };
    };
    _results = [];
    for (i = _i = 0, _ref = buttonList.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      buttonId = buttonList[i];
      button = document.createElement("i");
      button.className = "fa fa-" + buttonAwesome[buttonId];
      _fn(buttonId);
      button.style.WebkitTapHighlightColor = "rgba(0,0,0,0)";
      button.style.tapHighlightColor = "rgba(0,0,0,0)";
      button.style.position = "absolute";
      button.style.fontSize = "36px";
      button.style.padding = "4px";
      button.style.top = i < buttonList.length / 2 ? "0px" : "" + (window.innerHeight - 44) + "px";
      s = (window.innerWidth - buttonList.length / 2 * 44) / (buttonList.length / 2 - 1) + 44;
      button.style.left = "" + ((i % (buttonList.length / 2)) * s) + "px";
      _results.push(buttons.appendChild(button));
    }
    return _results;
  };

  touchstart = function(x, y) {
    if (loadGrid) {
      return loadGridHandleTouch(x, y);
    }
    document.getElementById("info").style.opacity = "0";
    uu.sleep(1, function() {
      return document.getElementById("info").style.display = "none";
    });
    nextPath = [x / scale - rootX, y / scale - rootY];
    nextStroke = {
      prev: currentStroke.date,
      path: nextPath,
      date: Date.now()
    };
    kind = "draw";
    return multitouch = void 0;
  };

  touchend = function() {
    if ("draw" === kind) {
      allStrokes[nextStroke.date] = nextStroke;
      localforage.setItem("sketchStroke" + nextStroke.date, nextStroke);
      localforage.setItem("sketchCurrent", nextStroke.date);
      currentStroke = nextStroke;
    }
    return kind = "end";
  };

  touchmove = function(x0, y0, x1, y1) {
    var current, x, y;
    if ("draw" === kind) {
      x = x0 / scale - rootX;
      y = y0 / scale - rootY;
      drawSegment(nextPath[nextPath.length - 2], nextPath[nextPath.length - 1], x, y);
      nextPath.push(x, y);
    }
    if ("pan" === kind) {
      if (panPos) {
        rootX += (x0 - panPos.x) / scale;
        rootY += (y0 - panPos.y) / scale;
        redraw();
      }
      panPos = {
        x: x0,
        y: y0
      };
    }
    if ("number" === typeof x1) {
      kind = "multitouch";
      if (!multitouch) {
        kind = "multitouch";
        return multitouch = {
          x: (x0 + x1) / 2 / scale - rootX,
          y: (y0 + y1) / 2 / scale - rootY,
          dist: dist(x0, y0, x1, y1),
          rootX: rootX,
          rootY: rootY,
          scale: scale
        };
      } else {
        current = {
          x: (x0 + x1) / 2 / multitouch.scale - multitouch.rootX,
          y: (y0 + y1) / 2 / multitouch.scale - multitouch.rootY,
          dist: dist(x0, y0, x1, y1)
        };
        scale = multitouch.scale * current.dist / multitouch.dist;
        rootX = (current.x + multitouch.rootX) * multitouch.scale / scale - multitouch.x;
        rootY = (current.y + multitouch.rootY) * multitouch.scale / scale - multitouch.y;
        return uu.nextTick(redraw());
      }
    }
  };

  loadDB = function() {
    var current, doFetch, done, fetchAll;
    console.log("HERE");
    doFetch = [];
    current = void 0;
    fetchAll = function() {
      var id;
      if (doFetch.length === 0) {
        return done();
      }
      id = doFetch.pop();
      return localforage.getItem("sketchStroke" + id, function(stroke) {
        if (!stroke) {
          return;
        }
        allStrokes[id] = stroke;
        if (stroke.prev !== 1) {
          doFetch.push(stroke.prev);
        }
        if (stroke.prevSave) {
          doFetch.push(stroke.prevSave);
        }
        return fetchAll();
      });
    };
    done = function() {
      currentStroke = allStrokes[current];
      return redraw();
    };
    return localforage.getItem("sketchCurrent", function(id) {
      current = id;
      doFetch.push(current);
      return localforage.getItem("sketchSaved", function(saved) {
        doFetch.push(saved);
        return fetchAll();
      });
    });
  };

  onReady(function() {
    loadDB();
    ctx = canvas.getContext("2d");
    layout();
    uu.domListen(window, "touchstart", function(e) {
      e.preventDefault();
      hasTouch = true;
      if (1 === e.touches.length) {
        return touchstart(e.touches[0].clientX * devicePixelRatio, e.touches[0].clientY * devicePixelRatio);
      }
    });
    uu.domListen(window, "mousedown", function(e) {
      e.preventDefault();
      if (!hasTouch) {
        return touchstart(e.clientX * devicePixelRatio, e.clientY * devicePixelRatio);
      }
    });
    uu.domListen(window, "touchmove", function(e) {
      var args, touch, _i, _len, _ref;
      e.preventDefault();
      args = [];
      _ref = e.touches;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        touch = _ref[_i];
        args.push(touch.clientX * devicePixelRatio);
        args.push(touch.clientY * devicePixelRatio);
      }
      return touchmove.apply(null, args);
    });
    uu.domListen(window, "mousemove", function(e) {
      e.preventDefault();
      return touchmove(e.clientX * devicePixelRatio, e.clientY * devicePixelRatio);
    });
    uu.domListen(window, "touchend", function(e) {
      return touchend();
    });
    uu.domListen(window, "mouseup", function(e) {
      if (!hasTouch) {
        return touchend();
      }
    });
    return uu.domListen(window, "resize", function(e) {
      return layout();
    });
  });

}).call(this);
