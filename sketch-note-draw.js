// Generated by CoffeeScript 1.6.3
(function() {
  var ctx, drawSegment, hold, info, layout, onReady, redraw, rootX, rootX0, rootY, rootY0, scale, scale0, stroke, strokes, t, transform, use,
    __slice = [].slice;

  if (typeof isNodeJs === "undefined" || typeof runTest === "undefined") {
    (function() {
      var root;
      root = typeof window === "undefined" ? global : window;
      if (typeof isNodeJs === "undefined") {
        root.isNodeJs = typeof process !== "undefined";
      }
      if (typeof isWindow === "undefined") {
        root.isWindow = typeof window !== "undefined";
      }
      if (typeof isPhoneGap === "undefined") {
        root.isPhoneGap = typeof (typeof document !== "undefined" && document !== null ? document.ondeviceready : void 0) !== "undefined";
      }
      if (typeof runTest === "undefined") {
        return root.runTest = (isNodeJs ? process.argv[2] === "test" : location.hash.slice(1) === "test");
      }
    })();
  }

  use = isNodeJs ? (function(module) {
    return require(module);
  }) : (function(module) {
    return window[module];
  });

  onReady = function(fn) {
    if (isWindow) {
      if (document.readystate !== "complete") {
        return fn();
      } else {
        return setTimeout((function() {
          return onReady(fn);
        }), 17);
      }
    }
  };

  t = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

  info = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    t.shift();
    t.push(args);
    return log.innerHTML = JSON.stringify(t);
  };

  strokes = [];

  stroke = [];

  transform = false;

  hold = false;

  rootX = rootX0 = 0;

  rootY = rootY0 = 0;

  scale = scale0 = 1;

  ctx = void 0;

  redraw = function() {
    var i, _i, _j, _len, _ref, _results;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    _results = [];
    for (_i = 0, _len = strokes.length; _i < _len; _i++) {
      stroke = strokes[_i];
      ctx.beginPath();
      ctx.moveTo((stroke[0] + rootX) * scale, (stroke[1] + rootY) * scale);
      for (i = _j = 2, _ref = stroke.length; _j <= _ref; i = _j += 2) {
        ctx.lineTo((stroke[i] + rootX) * scale, (stroke[i + 1] + rootY) * scale);
      }
      _results.push(ctx.stroke());
    }
    return _results;
  };

  drawSegment = function(x0, y0, x1, y1) {
    ctx.beginPath();
    ctx.moveTo((x0 + rootX) * scale, (y0 + rootY) * scale);
    ctx.lineTo((x1 + rootX) * scale, (y1 + rootY) * scale);
    return ctx.stroke();
  };

  layout = function() {
    canvas.style.position = "absolute";
    canvas.style.top = "0px";
    canvas.style.left = "0px";
    canvas.width = window.innerWidth;
    return canvas.height = window.innerHeight;
  };

  onReady(function() {
    var events;
    ctx = canvas.getContext("2d");
    layout();
    events = Hammer(window);
    events.on("drag", function(e) {
      var x, y;
      x = e.gesture.touches[0].clientX / scale - rootX;
      y = e.gesture.touches[0].clientY / scale - rootY;
      drawSegment(stroke[stroke.length - 2], stroke[stroke.length - 1], x, y);
      return stroke.push(x, y);
    });
    events.on("dragstart", function(e) {
      var x, y;
      x = e.gesture.touches[0].clientX / scale - rootX;
      y = e.gesture.touches[0].clientY / scale - rootY;
      stroke = [x, y];
      console.log("dragstart");
      transform = false;
      return hold = false;
    });
    events.on("transformstart transformend", function() {
      return transform = true;
    });
    events.on("transformstart", function(e) {
      scale0 = scale;
      rootX0 = rootX - e.gesture.deltaX;
      return rootY0 = rootY - e.gesture.deltaY / scale;
    });
    events.on("transform", function(e) {
      rootX = rootX0 + e.gesture.deltaX / scale;
      rootY = rootY0 + e.gesture.deltaY / scale;
      scale = scale0 * e.gesture.scale;
      return redraw();
    });
    events.on("hold tap", function(e) {
      console.log(e);
      hold = true;
      return redraw();
    });
    return events.on("dragend", function() {
      if (!transform && !hold) {
        return strokes.push(stroke);
      } else {
        return redraw();
      }
    });
  });

}).call(this);
